diff -up bash-3.2/config-top.h.command_not_found bash-3.2/config-top.h
--- bash-3.2/config-top.h.command_not_found	2008-12-04 15:45:21.000000000 +0100
+++ bash-3.2/config-top.h	2008-12-04 15:45:55.000000000 +0100
@@ -87,3 +87,7 @@
 /* Define this if you want bash to try to check whether it's being run by
    sshd and source the .bashrc if so (like the rshd behavior). */
 #define SSH_SOURCE_BASHRC
+
+/* Define this if you want  bash to try to find command_not_found_handler
+   shell function */
+#define COMMAND_NOT_FOUND_HANDLER
diff -up bash-3.2/execute_cmd.c.command_not_found bash-3.2/execute_cmd.c
--- bash-3.2/execute_cmd.c.command_not_found	2008-12-04 15:34:48.000000000 +0100
+++ bash-3.2/execute_cmd.c	2008-12-04 15:34:52.000000000 +0100
@@ -3737,10 +3737,33 @@ execute_disk_command (words, redirects, 
 
       if (command == 0)
 	{
+#if defined (COMMAND_NOT_FOUND_HANDLER)
+          SHELL_VAR *f, *v;
+          WORD_LIST *cmdlist;
+          WORD_DESC *w;
+          int fval;
+          if ( (posixly_correct || interactive_shell == 0) ||
+             ( f = find_function ("command_not_found_handler")) == 0)
+            {
+	      internal_error (_("%s: command not found"), pathname);
+	      exit (EX_NOTFOUND);     /* Posix.2 says the exit status is 127 */
+	    }
+	  w = make_word("command_not_found_handler");
+	  cmdlist = make_word_list(w, (WORD_LIST*)NULL);
+
+	  w = make_word(pathname);
+	  cmdlist->next = make_word_list(w, (WORD_LIST*)NULL);
+	   
+	  fval = execute_shell_function (f, cmdlist);
+	  if (fval == EX_NOTFOUND)
+	    internal_error (_("%s: command not found"), pathname);
+	  exit(fval);
+ 	}
+#else
 	  internal_error (_("%s: command not found"), pathname);
 	  exit (EX_NOTFOUND);	/* Posix.2 says the exit status is 127 */
 	}
-
+#endif
       /* Execve expects the command name to be in args[0].  So we
 	 leave it there, in the same format that the user used to
 	 type it in. */
